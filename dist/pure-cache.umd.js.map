{"version":3,"file":"pure-cache.umd.js","sources":["../node_modules/mitt/dist/mitt.es.js","../src/constants/events.js","../src/utils/checkInstanceDisposal.js","../src/constants/inMemoryDefaultConfig.js","../src/inMemoryExpirer.js","../src/constants/pureCacheDefaultConfig.js","../src/pureCache.js"],"sourcesContent":["//      \n// An event handler can take an optional event argument\n// and should not return a value\n                                          \n                                                               \n\n// An array of all currently registered event handlers for a type\n                                            \n                                                            \n// A map of event types and their corresponding event handlers.\n                        \n                                 \n                                   \n  \n\n/** Mitt: Tiny (~200b) functional event emitter / pubsub.\n *  @name mitt\n *  @returns {Mitt}\n */\nfunction mitt(all                 ) {\n\tall = all || Object.create(null);\n\n\treturn {\n\t\t/**\n\t\t * Register an event handler for the given type.\n\t\t *\n\t\t * @param  {String} type\tType of event to listen for, or `\"*\"` for all events\n\t\t * @param  {Function} handler Function to call in response to given event\n\t\t * @memberOf mitt\n\t\t */\n\t\ton: function on(type        , handler              ) {\n\t\t\t(all[type] || (all[type] = [])).push(handler);\n\t\t},\n\n\t\t/**\n\t\t * Remove an event handler for the given type.\n\t\t *\n\t\t * @param  {String} type\tType of event to unregister `handler` from, or `\"*\"`\n\t\t * @param  {Function} handler Handler function to remove\n\t\t * @memberOf mitt\n\t\t */\n\t\toff: function off(type        , handler              ) {\n\t\t\tif (all[type]) {\n\t\t\t\tall[type].splice(all[type].indexOf(handler) >>> 0, 1);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Invoke all handlers for the given type.\n\t\t * If present, `\"*\"` handlers are invoked after type-matched handlers.\n\t\t *\n\t\t * @param {String} type  The event type to invoke\n\t\t * @param {Any} [evt]  Any value (object is recommended and powerful), passed to each handler\n\t\t * @memberOf mitt\n\t\t */\n\t\temit: function emit(type        , evt     ) {\n\t\t\t(all[type] || []).slice().map(function (handler) { handler(evt); });\n\t\t\t(all['*'] || []).slice().map(function (handler) { handler(type, evt); });\n\t\t}\n\t};\n}\n\nexport default mitt;\n//# sourceMappingURL=mitt.es.js.map\n","/**\n * Events list\n */\nexport default {\n  EXPIRY: \"expiry\",\n  ADD: \"add\",\n  GET: \"get\",\n  REMOVE: \"remove\",\n  CLEAR: \"clear\"\n};\n","const checkIfInstanceIsDisposed = instanceDisposed => {\n  if (instanceDisposed) {\n    throw new Error(\"Cannot use disposed instance.\");\n  }\n};\n\nexport default checkIfInstanceIsDisposed;\n","/**\n * In memory default config\n * */\nconst inMemoryDefaultConfig = {\n  // By default, check for cache expiry every 100 ms\n  // Reducing this value might create performance issues\n  expiryCheckInterval: 100\n};\n\nexport default inMemoryDefaultConfig;\n","import checkIfInstanceIsDisposed from \"./utils/checkInstanceDisposal\";\nimport defaultConfig from \"./constants/inMemoryDefaultConfig\";\n\n/**\n * Near realtime expiry handler\n *\n * queue Structure:\n *  {\n *    time1: [{key: key1, onExpire: () => {}}, {key: key2, onExpire: () => {}}],\n *    time2: [{key: key3, onExpire: () => {}}]\n *  }\n */\nclass InMemoryExpirer {\n  constructor(config = {}) {\n    // Configuration\n    this.config = { ...defaultConfig, ...config };\n\n    // Expirer queue\n    this.queue = {};\n\n    // Instance dispose status\n    this.disposed = false;\n\n    // Store last expired time to navigate from current expired time to last expired time\n    // Set initial value to current time - 1\n    // Don't set to 0 as expiry function will loop from current time to 0\n    this.lastExpiredTime = Date.now() - 1;\n\n    // Run the expiry function at every configured interval time\n    const { expiryCheckInterval } = this.config;\n    this.timer = setInterval(this.expire, expiryCheckInterval);\n  }\n\n  /**\n   * Expiry function\n   * */\n  expire = () => {\n    checkIfInstanceIsDisposed(this.disposed);\n\n    const time = Date.now();\n\n    for (let t = time; t >= this.lastExpiredTime; t -= 1) {\n      const toExpire = this.queue[t];\n\n      if (toExpire) {\n        delete this.queue[t];\n        toExpire.forEach(({ key, onExpire }) => onExpire(key));\n      }\n    }\n\n    this.lastExpiredTime = time;\n  };\n\n  /**\n   * Add to expiry queue\n   *\n   * @param {Number} time  When to expire\n   * @param {String} key key to store expiry data against\n   * @param {Function} onExpire Expiry callback, called when Date.now() ~= time\n   * */\n  add(time, key, onExpire) {\n    checkIfInstanceIsDisposed(this.disposed);\n\n    if (!this.queue[time]) {\n      this.queue[time] = [];\n    }\n\n    this.queue[time].push({ key, onExpire });\n\n    return true;\n  }\n\n  /**\n   * Remove specific key from expiry queue\n   *\n   * @param {Number} time  Expiry time\n   * @param {String} key key to remove from the expiry queue\n   * */\n  remove(time, key) {\n    checkIfInstanceIsDisposed(this.disposed);\n\n    const queue = this.queue[time];\n\n    if (queue) {\n      // Filter out keys in queue[time] which are matching current remove key\n      const filteredQueue = queue.filter(({ key: k }) => k !== key);\n      if (!filteredQueue.length) {\n        delete this.queue[time];\n      } else {\n        this.queue[time] = filteredQueue;\n      }\n\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Cleanup - Empty queue & clear expirer timer\n   * */\n  dispose() {\n    checkIfInstanceIsDisposed(this.disposed);\n\n    clearInterval(this.timer);\n    this.timer = null;\n    this.queue = {};\n    this.disposed = true;\n\n    return true;\n  }\n}\n\nexport default InMemoryExpirer;\n","/**\n * Pure cache default config\n * */\nconst pureCacheDefaultConfig = {\n  // Default cache expiry time, 60000ms(60s) by default\n  // Set `false` to disable expiry(This beats the purpose of cache, the data is store until the instance is disposed)\n  // Note: Falsy values like `0` will be treated as `false`\n  defaultCacheExpiryIn: 60000,\n  // By default, check for cache expiry every 100 ms\n  // Reducing this value might create performance issues\n  expiryCheckInterval: 100\n};\n\nexport default pureCacheDefaultConfig;\n","import mitt from \"mitt\";\nimport Events from \"./constants/events\";\nimport InMemoryExpirer from \"./inMemoryExpirer\";\nimport checkIfInstanceIsDisposed from \"./utils/checkInstanceDisposal\";\nimport defaultConfig from \"./constants/pureCacheDefaultConfig\";\n\n/**\n * pure-cache: Cache with confidence ðŸŽ‰ Ultra fast in-memory JavaScript cache with near realtime cache expiry feature âš¡\n *\n * cacheStore Structure:\n *    {\n *      key1: { value: value1, addedAt: 1527012874728, expiryAt: 1527012879729 },\n *      key2: { value: value2, addedAt: 1527012908893, expiryAt: 1527012909880 },\n *      ...\n *    }\n */\nclass PureCache {\n  constructor(config = {}, Expirer = InMemoryExpirer) {\n    // Configuration\n    this.config = { ...defaultConfig, ...config };\n\n    // Event listeners\n    const { on, off, emit } = mitt();\n    [this.on, this.off, this.emit] = [on, off, emit];\n\n    // Cache store\n    this.cacheStore = {};\n\n    // Instance dispose status\n    this.disposed = false;\n\n    // Create cache expirer instance, which maintains its own expiry queue\n    const { expiryCheckInterval } = this.config;\n    this.cacheExpirer = new Expirer({ expiryCheckInterval });\n  }\n\n  /**\n   * Put data into the cache\n   *\n   * @param {String} key  Cache key\n   * @param {String|Object|*} value Value to be stored against cache key\n   * @param {Number} expiryIn Expiry time(in ms from now), defaults to `60000ms(60s)`,\n   *                          if set to falsy values(like `0` & `false`), cache will\n   *                          act as simple in-memory data store and data is never expired for the key\n   *\n   * @returns {Object} Newly added Object({ value, addedAt, expiryAt }) with `value` key consists of actual data\n   * */\n  put(key = \"\", value = \"\", expiryIn = this.config.defaultCacheExpiryIn) {\n    checkIfInstanceIsDisposed(this.disposed);\n\n    // Remove existing values in the key(if any)\n    if (this.cacheStore[key]) {\n      this.remove(key);\n    }\n\n    const addedAt = Date.now();\n    // Ignore all falsy values(like `0` & `false`)\n    // Basically if there is no expiry, cache will act as simple in-memory data store\n    const expiryAt = expiryIn ? addedAt + expiryIn : null;\n    const target = { value, addedAt, expiryAt };\n    this.cacheStore[key] = target;\n\n    // If expiry time exists, add to expiry queue\n    if (expiryAt) {\n      // Remove value from cache and trigger expiry event\n      const onExpire = () => {\n        this.remove(key);\n        this.emit(Events.EXPIRY, {\n          key,\n          data: this.cacheStore[key]\n        });\n      };\n\n      this.cacheExpirer.add(expiryAt, key, onExpire);\n    }\n    this.emit(Events.ADD, { key, data: target });\n\n    return target;\n  }\n\n  /**\n   * Get data from the cache\n   *\n   * @param {String} key  Cache key\n   *\n   * @returns {Object|null} If `key` found, returns Object({ value, addedAt, expiryAt })\n   *                        with `value` key consists of actual data, else returns `null`\n   * */\n  get(key = \"\") {\n    checkIfInstanceIsDisposed(this.disposed);\n\n    const target = this.cacheStore[key];\n\n    if (target) {\n      this.emit(Events.GET, { key, data: target });\n      return target;\n    }\n\n    return null;\n  }\n\n  /**\n   * Remove data from the cache\n   *\n   * @param {String} key  Cache key to be removed from the cache\n   *\n   * @returns {Boolean} If `key` found, returns `true`,else returns `false`\n   * */\n  remove(key) {\n    checkIfInstanceIsDisposed(this.disposed);\n\n    const target = this.cacheStore[key];\n\n    if (target) {\n      // Remove key & value from cache\n      delete this.cacheStore[key];\n      const { expiryAt } = target;\n      // If timer exists for the key, remove it\n      this.cacheExpirer.remove(expiryAt, key);\n      this.emit(Events.REMOVE, { key, data: target });\n\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Cleanup - Clear entire cache & stop expirer\n   *\n   * @returns {Boolean} Returns `true`\n   * */\n  dispose() {\n    checkIfInstanceIsDisposed(this.disposed);\n\n    Object.keys(this.cacheStore).forEach(key => this.remove(key));\n    this.emit(Events.CLEAR, {});\n    this.cacheExpirer.dispose();\n    this.disposed = true;\n\n    return true;\n  }\n}\n\nexport default PureCache;\n"],"names":["mitt","all","Object","create","on","type","handler","push","off","splice","indexOf","emit","evt","slice","map","checkIfInstanceIsDisposed","instanceDisposed","Error","inMemoryDefaultConfig","expiryCheckInterval","InMemoryExpirer","config","_this","disposed","time","Date","now","t","lastExpiredTime","toExpire","queue","forEach","key","onExpire","defaultConfig","this","timer","setInterval","expire","filteredQueue","filter","length","clearInterval","pureCacheDefaultConfig","defaultCacheExpiryIn","Expirer","cacheStore","cacheExpirer","value","expiryIn","remove","addedAt","expiryAt","target","Events","data","add","keys","_this2","dispose"],"mappings":"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"}